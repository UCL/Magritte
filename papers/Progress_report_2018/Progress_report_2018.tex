\documentclass[]{article}
\usepackage[margin=1.1in, portrait]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage[english]{babel}
\usepackage{multirow}
\usepackage{graphicx}
\newtheorem{stel}{Stelling}
\usepackage{float}
\usepackage{textcomp}
\usepackage{footmisc}
\usepackage[colorlinks=true, urlcolor=blue, linkcolor=blue, citecolor=blue, pdfborder={0 0 0}, linktoc=page]{hyperref}
\setlength{\parindent}{0 pt}
\usepackage{etoolbox}
\usepackage{scrextend}

\newcommand{\kb}{k_{\text{B}}}
\newcommand{\D}{\text{d}}
\newcommand{\x}{\textbf{x}}
\newcommand{\n}{\hat{\textbf{n}}}
\newcommand{\e}{ \ = \ }
\newcommand{\Magritte}{\texttt{Magritte}}


\title{\textsc{Magritte}: optimizing a deterministic ray-tracer for radiative transfer on multiple computer architectures}

\author{F. De Ceuster, J. Yates, P.A. Boyle and J. Hetherington}
\date{}


\begin{document}

\maketitle


\begin{abstract}
The aim is to formulate the modern problem of computational radiative transfer and develop the solution strategy that is used in \Magritte: a new multidimensional accelerated general-purpose radiative transfer code.
\end{abstract}



\section{Introduction}

To obtain self-consistent radiative transfer and therml balance and chemistery, the way to go are iterations!
A first step in optimization is improving convergence. This can be done in various ways, \textsc{Magritte} a approximated lambda operator method by \cite{Rybicki1991} in combination with Ng-acceleration \cite{Ng1974}.
Appart from acceleration the convergence


We want to model the physical state at each point of a region in space at a certain time. To do this, we are given a set of

\bigskip

We want to

\bigskip

Consider a multidimensional space with a scalar field $I(\x,\n)$, depending on both the position $\x$ and the viewing direction $\n$ in that space. The geometric nature of the problem can be deduced from the the transfer equation by explicitly writing all geometric (i.e. $\x$ and $\n$) dependencies


\begin{equation}
\n \cdot \nabla I(\x,\n) \e \eta(\x,\n) - \chi(\x) I(\x,\n)
\end{equation}


\subsection{Method of rays}

\subsubsection{Ray tracing algorithms}

\emph{Trace structured rays through an unstructered grid.}

\subsection{What is a good input for \Magritte?}
We choose to solve the problem by directly integrating the transfer equation along each ray. The result of this calculation is the intensity at a certain point in a certain direction.


\Magritte's input consists of an unstructered set of $N$ points in 3D space. For each of these points we have three position coordinates, three components of the velocity and a density.

\bigskip

We need to determine which point configurations are well-sampled by the ray tracer in \Magritte.

Angular versus radial resolution


\section{Basic data structure}

Array of structures (AoS) versus Structure of Arrays


\section{Input/output strategy}

Since we want to develop a general-purpose code, we need to make sure that it can handle many different types of input. The input can be user generated or come from the output of a hydrodynamics code. For both cases we will consider the best way to handle the conversion.


\subsection{Model input}

\Magritte needs as input a velocity and density distribution.


\subsection{Hydro output as input}
\bigskip

\emph{Fast conversion from the input grid to the grid used by $\Magritte$ and back.}

\subsubsection{AMR grid}

The simplest way to handle an AMR grid input is to use the centers of the grid cells as set input grid points $G$. However, this tends to produce an oversampled grid.



\subsubsection{SPH data}

A truely general-purpose code should be able to tackle problems of any size i.e. the only restriction on the problem size should come from the amount of available CPU time.  In order to achieve this one needs a way to devide the problem into smaller pieces which can be solved individually and communicated efficiently to form the solution.


\section{Parallellisation strategy}


\subsection{Questions}

\begin{itemize}
\item How are we going to devide the grid? Are there smart ways to cut over high opacities?
\item At which point in the calculation do we want to communicate?
\end{itemize}

\subsection{Strategies}

Work with ghost cells. Devide the total of cells up in subsets, one subset for each CPU. For each subset add the first neighbor not in the subset.


\section{Multi-frequency line transfer}



\section{Self-consistent temperature determination}

The physical parameters at each point in space strongly depend on the temperature.
In dedetmining the temperature we assume that this must be such that at each point in space there is no net heating or cooling, i.e. that at each point the heating is equal to the cooling.

\bigskip

Strategy: determine guess temperature on coarser grid.

\bigskip

Question:

How to obtain minimum and maximum temperatures from guess?





\section{Technical}


NOTE: The \texttt{next$\_$cell} DOES NOT terminate properly!

\bigskip

\emph{Reduction:} When we say that the grid is reduced around a certain cell this means that we remove the neighbouring cells. We only do this when a certain criterion is satisfied that assures us that the cell that we keep is representative for its neighbours.

\bigskip

To keep track of the cells after reduction, each cell has an identifier \texttt{cell[n].id}. This identifier will help us map the data form the reduced grid back to the original one.
\begin{equation*}
  \texttt{CELL cell [NCELLS]}
  \ \xrightarrow{\text{ REDUCE }} \ \left.
  \begin{cases}
    \ \ \texttt{CELL cell$\_$ori [NCELLS]} \\
    \ \ \texttt{CELL cell$\_$red [MCELLS]}
  \end{cases}
  \right\} \ \xrightarrow{\text{ APPEND }} \
  \texttt{CELL cell$\_$app [NCELLS]}
\end{equation*}
We initialize the identifier to be the cell number \texttt{cell[n].id = n}. After reduction there are two grids. In the original grid, \texttt{cell$\_$ori}, there are two possibilities for the identifier. If the cell is kept after reduction the identifier will still be equal to the cell number. If t Either the identifier is still equal to the number of the cell which means the the cell is kept after reduction, or the identifier is equal to the


\section*{Acknowledgements}
The authors would like to thank C.P. Dullemond and C. Brinch for helpful and encouraging discussions.

FDC is supported by the EPSRC iCASE studentship programme, Intel Corporation and Cray Inc.



\bibliography{library}
\bibliographystyle{ieeetr}



\end{document}
